# My TypeScript Journey: Earned Badges üèÜ

## Badges Overview

Here is a collection of badges I earned from completing Microsoft Learn's TypeScript modules:

1. **Getting Started with TypeScript**: [‚úîÔ∏è Badge](https://learn.microsoft.com/en-us/users/ranika23-7739/achievements/vkyw5zwm)
2. **Declare Variable Types in TypeScript**: [‚úîÔ∏è Badge](https://learn.microsoft.com/en-us/users/ranika23-7739/achievements/k5vakedb)
3. **Implement Interfaces in TypeScript**: [‚úîÔ∏è Badge](https://learn.microsoft.com/en-us/users/ranika23-7739/achievements/x23hc7wy)

## Reflections

| MODULE | REFLECTIONS |
| ------ | ------ |
| [Get started with TypeScript](https://learn.microsoft.com/en-us/training/modules/typescript-get-started/) | I've identified key differences between TypeScript and JavaScript, one of which is the type system, which allows you to better navigate the purpose of your code. For example, in TypeScript, you can determine the data type of a variable or parameter using the type hint . Another advantage of TypeScript is static type checking, which allows me to identify code problems early in the development process. I also learned how to customize a TypeScript project in Visual Studio Code. |
| [Declare Variable Types in TypeScript](https://learn.microsoft.com/en-us/training/modules/typescript-declare-variable-types/) | I highlighted the advantages of declaring typed variables in TypeScript, learned to declare variables using primitive types(boolean , number, string, enum, void types), object types(class, interface, array, literals types), union and intersection types, noted the specifics of using null and undefined types. I also noted the improvement of code readability criterion when using explicit type annotations. |
| [Implement Interfaces in TypeScript](https://learn.microsoft.com/en-us/training/modules/typescript-implement-interfaces/) | Familiarized myself with the concept of an interface, its main task, which is to describe a type. Also noted the cases in which the use of interfaces will be reasonable and useful, for example, for frequently used types or in the case of command work, when the objects implementing the interface must implement all the necessary members of the interface. In addition, interfaces will be useful in working with libraries by specifying fixed parameters for functions. In the module, I also noted the differences between interfaces and type aliases, which include the ability to extend an interface and the inability of a type alias to describe anything other than a union or tuple. I also practiced extending interfaces, declaring and creating an interface instance, and familiarized myself with other ways of using interfaces (in cases of creating indexed types, describing API) |
